# 设计模式



Creational Design Pattern 创建型模式（原工单抽建/建造单例工厂，抽象原型）
Structural Design Pattern 结构型模式（享代装适组外桥/享元装饰外观，代理桥接适配组合）
Behavioral Design Pattern 行为型模式 （中访观模，状解策命，责迭备）

## 一、Creational Design Pattern 创建型模式（原工单抽建/建造单例工厂，抽象原型）

### 1.1 Singleton 单例

单例（Singleton）模式： 某个类只能生成一个实例，该类提供了一个全局 访问点供外部获取该实例，其拓展是有限多例模式。
Singleton Pattern says that just"define a class that has only one instance and provides a global point of access to it".

Early Instantiation: creation of instance at load time.
Lazy Instantiation: creation of instance when required.

### 1.2 Prototype 原型

原型（Prototype）模式： 将一个对象作为原型，通过对其进行复制而克隆 出多个和原型类似的新实例。
cloning of an existing object instead of creating new one and can also be customized as per the requirement.

Advantage of Prototype Pattern
It reduces the need of sub-classing.
It hides complexities of creating objects.
The clients can get new objects without knowing which type of object it will be.
It lets you add or remove objects at runtime.

Usage of Prototype Pattern
When the classes are instantiated at runtime.
When the cost of creating an object is expensive or complicated.
When you want to keep the number of classes in an application minimum.
When the client application needs to be unaware of object creation and representation.

### 1.3 Factory Method 工厂方法

工厂方法（Factory Method）模式： 定义一个用于创建产品的接口，由子类决定生产什么产品。
define an interface or abstract class for creating an object but let the subclasses decide which class to instantiate. In other words, subclasses are responsible to create the instance of the class.

Advantage of Factory Design Pattern
Factory Method Pattern allows the sub-classes to choose the type of objects to create.
It promotes the loose-coupling by eliminating the need to bind application-specific classes into the code. That means the code interacts solely with the resultant interface or abstract class, so that it will work with any classes that implement that interface or that extends that abstract class.

### 1.4 抽象工厂（AbstractFactory）

抽象工厂（AbstractFactory）模式： 提供一个创建产品族的接口，其每个 子类可以生产一系列相关的产品。
define an interface or abstract class for creating families of related (or dependent) objects but without specifying their concrete sub-classes.That means Abstract Factory lets a class returns a factory of classes. So, this is the reason that Abstract Factory Pattern is one level higher than the Factory Pattern.

Advantage of Abstract Factory Pattern
Abstract Factory Pattern isolates the client code from concrete (implementation) classes.
It eases the exchanging of object families.
It promotes consistency among objects.

Usage of Abstract Factory Pattern
When the system needs to be independent of how its object are created, composed, and represented.
When the family of related objects has to be used together, then this constraint needs to be enforced.
When you want to provide a library of objects that does not show implementations and only reveals interfaces.
When the system needs to be configured with one of a multiple family of objects.

### 1.5 建造者（Builder）

建造者（Builder）模式： 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
construct a complex object from simple objects using step-by-step approach。It is mostly used when object can't be created in single step like in the de-serialization of a complex object.

Advantage of Builder Design Pattern
It provides clear separation between the construction and representation of an object.
It provides better control over construction process.
It supports to change the internal representation of objects.

## 二、Structural Design Pattern 结构型模式（享代装适组外桥/享元装饰外观，代理桥接适配组合）

### 2.1 代理（Proxy）

代理（Proxy）模式： 为某对象提供一种代理以控制对该对象的访问。即客 户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
provides the control for accessing the original object
Proxy pattern is also known as Surrogate or Placeholder.

### 2.2 适配器（Adapter）

适配器（Adapter）模式： 将一个类的接口转换成客户希望的另外一个接口， 使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
converts the interface of a class into another interface that a client wants

Advantage of Adapter Pattern
It allows two or more previously incompatible objects to interact.
It allows reusability of existing functionality.

### 2.3 桥接（Bridge）

桥接（Bridge）模式： 将抽象与实现分离，使它们可以独立变化。它是用组 合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
decouple the functional abstraction from the implementation so that the two can vary independently
The Bridge Pattern is also known as Handle or Body.

Advantage of Bridge Pattern
It enables the separation of implementation from the interface.
It improves the extensibility.
It allows the hiding of implementation details from the client.

### 2.4 装饰（Decorator）

装饰（Decorator）模式： 动态的给对象增加一些职责，即增加其额外的功能。
attach a flexible additional responsibilities to an object dynamically
The Decorator Pattern is also known as Wrapper.

Advantage of Decorator Pattern
It provides greater flexibility than static inheritance.
It enhances the extensibility of the object, because changes are made by coding new classes.
It simplifies the coding by allowing you to develop a series of functionality from targeted classes instead of coding all of the behavior into the object.

### 2.5 外观（Facade）

外观（Facade）模式： 为多个复杂的子系统提供一个一致的接口，使这些子 系统更加容易被访问。
just provide a unified and simplified interface to a set of interfaces in a subsystem, therefore it hides the complexities of the subsystem from the client

Advantage of Facade Pattern
It shields the clients from the complexities of the sub-system components.
It promotes loose coupling between subsystems and its clients.just provide a unified and simplified interface to a set of interfaces in a subsystem, therefore it hides the complexities of the subsystem from the client

### 2.6 享元（Flyweight）

享元（Flyweight）模式： 运用共享技术来有效地支持大量细粒度对象的复用。
to reuse already existing similar kind of objects by storing them and create new object when no matching object is found

Advantage of Flyweight Pattern
It reduces the number of objects.
It reduces the amount of memory and storage devices required if the objects are persisted
Usage of Flyweight Pattern
When an application uses number of objects
When the storage cost is high because of the quantity of objects.
When the application does not depend on object identity.

### 2.7 组合（Composite）

组合（Composite）模式： 将对象组合成树状层次结构，使用户对单个对象 和组合对象具有一致的访问性。
allow clients to operate in generic manner on objects that may or may not represent a hierarchy of objects

Advantage of Composite Design Pattern
It defines class hierarchies that contain primitive and complex objects.
It makes easier to you to add new kinds of components.
It provides flexibility of structure with manageable class or interface.

Usage of Composite Pattern
It is used:
When you want to represent a full or partial hierarchy of objects.
When the responsibilities are needed to be added dynamically to the individual objects without affecting other objects. Where the responsibility of object may vary from time to time.

## 三、Behavioral Design Pattern 行为型模式 （中访观模，状解策命，责迭备）

### 3.1 模板方法（TemplateMethod）

模板方法（TemplateMethod）模式： 定义一个操作中的算法骨架，而将算 法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定 义该算法的某些特定步骤。
just define the skeleton of a function in an operation, deferring some steps to its subclasses

Benefits:
It is very common technique for reusing the code.This is only the main benefit of it.

Usage:
It is used when the common behavior among sub-classes should be moved to a single common class by avoiding the duplication.

### 3.2 策略（Strategy）

策略（Strategy）模式： 定义了一系列算法，并将每个算法封装起来，使它 们可以相互替换，且算法的改变不会影响使用算法的客户。
defines a family of functionality, encapsulate each one, and make them interchangeable
The Strategy Pattern is also known as Policy.

Benefits:
It provides a substitute to subclassing.
It defines each behavior within its own class, eliminating the need for conditional statements.
It makes it easier to extend and incorporate new behavior without changing the application.

Usage:
When the multiple classes differ only in their behaviors.e.g. Servlet API.
It is used when you need different variations of an algorithm.

### 3.3 命令（Command）

命令（Command）模式： 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
encapsulate a request under an object as a command and pass it to invoker object. Invoker object looks for the appropriate object which can handle this command and pass the command to the corresponding object and that object executes the command
It is also known as Action or Transaction.

Advantage of command pattern
It separates the object that invokes the operation from the object that actually performs the operation.
It makes easy to add new commands, because existing classes remain unchanged.

Usage of command pattern:
When you need parameterize objects according to an action perform.
When you need to create and execute requests at different times.
When you need to support rollback, logging or transaction functionality.

### 3.4 职责链（Chain of Responsibility）

职责链（Chain of Responsibility）模式： 把请求从链中的一个对象传到下 一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
avoid coupling the sender of a request to its receiver by giving multiple objects a chance to handle the request"
In other words, we can say that normally each receiver contains reference of another receiver. If one object cannot handle the request then it passes the same to the next receiver and so on.

Advantage of Chain of Responsibility Pattern
It reduces the coupling.
It adds flexibility while assigning the responsibilities to objects.
It allows a set of classes to act as one; events produced in one class can be sent to other handler classes with the help of composition.

### 3.5 状态（State）

状态（State）模式： 允许一个对象在其内部状态发生改变时改变其行为能力。
the class behavior changes based on its state.
In State Pattern, we create objects which represent various states and a context object whose behavior varies as its state object changes.
The State Pattern is also known as Objects for States.

Benefits:
It keeps the state-specific behavior.
It makes any state transitions explicit.
Usage:
When the behavior of object depends on its state and it must be able to change its behavior at runtime according to the new state.
It is used when the operations have large, multipart conditional statements that depend on the state of an object.

### 3.6 观察者（Observer）

观察者（Observer）模式： 多个对象间存在一对多关系，当一个对象发生改 变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
just define a one-to-one dependency so that when one object changes state, all its dependents are notified and updated automatically
The observer pattern is also known as Dependents or Publish-Subscribe.

### 3.7 中介者（Mediator）

中介者（Mediator）模式： 定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
to define an object that encapsulates how a set of objects interact
Mediator pattern is used to reduce communication complexity between multiple objects or classes. This pattern provides a mediator class which normally handles all the communications between different classes and supports easy maintainability of the code by loose coupling.

Benefits:
It decouples the number of classes.
It simplifies object protocols.
It centralizes the control.
The individual components become simpler and much easier to deal with because they don't need to pass messages to one another.
The components don't need to contain logic to deal with their intercommunication and therefore, they are more generic.

### 3.8 迭代器（Iterator）

迭代器（Iterator）模式： 提供一种方法来顺序访问聚合对象中的一系列数 据，而不暴露聚合对象的内部表示。
to access the elements of an aggregate object sequentially without exposing its underlying implementation
The Iterator pattern is also known as Cursor.

Advantage of Iterator Pattern
It supports variations in the traversal of a collection.
It simplifies the interface to the collection.

### 3.9 访问者（Visitor）

访问者（Visitor）模式： 在不改变集合元素的前提下，为一个集合中的每个 元素提供多种访问方式，即每个元素有多个访问者对象访问。
备忘录（Memento）模式： 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
to restore the state of an object to its previous state. But it must do this without violating Encapsulation. Such case is useful in case of error or failure.
The Memento pattern is also known as Token.
Undo or backspace or ctrl+z is one of the most used operation in an editor. Memento design pattern is used to implement the undo operation. This is done by saving the current state of the object as it changes state.

Benefits:
It preserves encapsulation boundaries.
It simplifies the originator.

### 3.10 解释器（Interpreter）

解释器（Interpreter）模式： 提供如何定义语言的文法，以及对语言句子的 解释方法，即解释器。
to define a representation of grammar of a given language, along with an interpreter that uses this representation to interpret sentences in the language
Basically the Interpreter pattern has limited area where it can be applied. We can discuss the Interpreter pattern only in terms of formal grammars but in this area there are better solutions that is why it is not frequently used.