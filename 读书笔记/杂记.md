## 1、无状态和有状态
不变模式有两种形式：一种是弱不变模式，另一种是强不变模式。
### 弱不变模式：
一个类的实例的状态是不可变化的，但是这个类的引用的实例具有可能会变化的状态。这样的类符合弱不变模式的定义。要实现弱不变模式，一个类必须满足如下条件：

 - 对象没有任何方法会修改对象的状态，当对象的构造函数对对象的状态初始化之后，对象的状态便不再改变。
 - 所有的属性都应当是私有的，防客户端对象直接修改任何的内部状态。
 - 第三，这个对象所引用的对象如果是可变对象的话，必须设法限制外界对这个对象的访问，以防止对这些对象的修改。如果可能应该尽量在不变对象的内部来初始化。

#### 弱不变模式的缺点是：
一个弱不变对象引用的实例变量可以是可变对象，可能会通过外界修改父对象的状态，这是一个显著的缺点。可以在初始化可变对象时，先进行clone。

解决方法：
在事务处理及数据大批量入库的多线程环境中，应该也会有类似的问题。所以对于这样的传入参数及上例中的不变对象引用可变对象,我们可以将其在相关构造函数及方法中复制为本地变量(数组),及使用它的深度clone,阻止相关数据与外部线程的联系。

### 强不变模式：
一个类的实例的状态不会改变，同时它的子类的实例也具有不可变化的状态。这样的类符合强不变模式。要实现强不变模式，一个类必须首先满足弱不变模式所要求的所有条件，并且还要满足下面条件之一：

 - 所考虑的类所有的方法都应当是final，这样这个类的子类不能够置换掉此类的方法。
 - 这个类本身就是final的，那么这个类就不可能会有子类，从而也就不可能有被子类修改的问题。

### 优缺点：
不变模式可增强对象的健壮性。不变模式允许多个对象共享某一对象，降低了对该对象进行并发访问时的同步化开销。唯一缺点是一旦需要修改一个不变对象的状态，就只好创建一个新的同类对象，在需要频繁修改不变对象的环境里，会有大量的不变对象作为中间结果被创建出来，再被Java的垃圾收集器收走，这是一种资源的浪费。

### 总结：
不变模式的核心就是对象不变，从而引伸出对象复用共享的思想。如无状态的单例模式，享元(Flyweight)模式及原型模式(Prototype)都可以认为是不变模式的应用。其它如线程池，缓存等的实现也一定程度上是使用不变模式。还有EJB的Stateless Session Bean(无状态会话bean),Spring对Service层、Dao层bean的默认单例实现，我认为都是沿用了不变模式中共享的思想。

### 基本概念：
有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。
无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。

### 单例模式中的有状态和无状态:
单例类可以是有状态的（stateful），一个有状态的单例对象一般也是可变（mutable）单例对象。有状态的可变的单例对象常常当做状态库（repositary）使用。比如一个单例对象TaskCache（Spring中配为singleton）可以持有一个AtomicLong类型的属性，用来给一个系统提供一个数值惟一的序列号码，作为任务通迅管理的ID生成器。同时，一个单例类也可以持有一个聚集，从而允许存储多个状态，如示例中的ExpiringMap缓存任务列表。

单例类也可以是没有状态的（stateless），仅用做提供工具性函数的对象。既然是为了提供工具性函数，也就没有必要创建多个实例，因此使用单例模式很合适。平常的单例类都是没有状态的，这里就不示例了。一个没有状态的单例类也就是不变（Immutable）单例类。

如何解决Servlet和Struts1的线程安全问题，当我们能比较好的理解有状态和无状态的原理，自然很容易得出结论：不要使用有状态的bean,也就是不要用实例变量。如果用，就要用prototype模式。Struts1 user guide里有： Only Use Local Variables - The most important principle that aids in thread-safe coding is to use only local variables, not instance variables , in your Action class.

总结：
Stateless无状态用单例Singleton模式，Stateful有状态就用原型Prototype模式。
Stateful 有状态是多线程编码的天敌，所以在开发中尽量用Stateless无状态，无状态是不变(immutable)模式的应用，有很多优点：不用管线程和同步的问题，如果值是不可变的，程序不用担心多个线程改变共享状态，所以可以避免线程竞争的bugs. 因为没有竞争，就不用用locks等机制，所以无状态的不变机制，也可以避免产生死锁现象

[有状态bean和无状态bean的一些理解](http://www.moosepp.top/2016/08/21/%E6%9C%89%E7%8A%B6%E6%80%81bean%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81bean%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/)
