



**基于 Buffer**

传统的 I/O 是面向字节流或字符流的，以流式的方式顺序地从一个 Stream 中读取一个或多个字节, 因此也就不能随意改变读取指针的位置。

在 NIO 中，抛弃了传统的 I/O 流，而是引入了 Channel 和 Buffer 的概念。在 NIO 中，只能从 Channel 中读取数据到 Buffer 中或将数据从 Buffer 中写入到 Channel。

基于 Buffer 操作不像传统 IO 的顺序操作，NIO 中可以随意地读取任意位置的数据。



**同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。同步与异步是一组相对概念，针对的是自己等待还是别人通知**

**阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。 阻塞和非阻塞是一组相对概念，针对的是等待过程中，等待者的操作。**

非阻塞不一定做到异步。非阻塞只是意味着方法调用不阻塞，但是通过事件通知的方式给调用线程一个机会去完成。它的逻辑是“等可以读（写）了告诉你”。这意味着工作的完成者仍然是调用者（线程）。

而异步不只是意味着方法调用不阻塞，它还意味着工作的完成已经转移到别的线程。意思是，只要你把工作交给了我，工作就“交”给了我。也许你会传个回调函数给我，但是函数的调用仍然是由“我”来完成的。你在发出调用以后，不再需要任何的工作。调用发出了，你的工作就完成了。我的工作开始了。工作转移到我这边。我是下一步。你可以接下去做别的工作。
异步在现有程序以外新开了线程。

如果说在异步IO以前，所有的程序必须自行处理IO问题。那么，有了异步IO，程序就彻底从IO的负担中解脱出来了：1，I/O工作被彻底从原有线程中分离出去。原有线程在I/O工作中除了把I/O目的告诉异步I/O API，它不需要做任何额外的工作（为了完成原有的I/O任务）；2，I/O工作在独立的线程中完成，不管它有或可能产生任何问题，这种问题也不可能POP UP到调用者线程即代码中去。调用者线程甚至不需要去捕捉任何I/O异常！



![img](https://img-blog.csdn.net/20161129103222584)





