

子类同步方法调用了父类同步方法，如没有可重入的特性，则会发生死锁；

Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。

conditional

两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。

对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。

锁级别的不同，对象头里会存储不同的内容。偏向锁存储的是当前占用此对象的线程ID；而轻量级则存储指向线程栈中锁记录的指针。重量级锁是什么？

线程的状态转变

锁级别的不同，对象头里会存储不同的内容。偏向锁存储的是当前占用此对象的线程ID；而轻量级则存储指向线程栈中锁记录的指针。

一个线程通过1号门进入Entry Set(入口区)，如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视区域的代码。如果在入口区中有其它线程在等待，那么新来的线程也会和这些线程一起等待。线程在持有监视器的过程中，有两个选择，一个是正常执行监视器区域的代码，释放监视器，通过5号门退出监视器；还有可能等待某个条件的出现，于是它会通过3号门到Wait Set（等待区）休息，直到相应的条件满足后再通过4号门进入重新获取监视器再执行。什么时候wait?

HotSpot
全局安全点

栈帧

锁升级过程中，线程状态的变化是什么？

底层的操作系统的Mutex Lock

通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。？

阻塞式IO操作结果返回，线程变为就绪状态。

lockSupport.unpark();

join?


**Blocked **与 **Waiting** 的区别
Blocked 是在等待其他线程释放 monitor 锁
Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。


操作系统的线程状态都有哪些

“同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。”，Timed Waiting 什么情况下会调用notify() 和 notifyAll()


Condition的使用及原理解析

sleep，wait, yield区别

suspend（）将线程挂起，此方法容易导致死锁 ? suspend是什么状态？
直接调用stop（）结束线程，该方法容易导致死锁 ？

永远不要调用线程对象的run()方法。调用start0方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直按调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。

JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待 CPU 使用权（操作系统层面处于可执行状态）与等待 I/O（操作系统层面处于休眠状态）没有区别，都是在等待某个资源，都归入了 RUNNABLE 状态。

- Reactor 主线程 MainReactor 对象通过 Select 监控建立连接事件，收到事件后通过 Acceptor 接收，处理建立连接事件；这里的select和epoll的那个是同样性质的吗？

读写锁的实现原理

三次握手，四次挥手，为什么挥手要四次？

redis属于单线程
6.0之前:命令执行过程为单线程，而链接，传输使用多路复用的模式
6.0之后:命令执行过程为单线程，而链接，传输使用多线程的模式

kafka为什么是基于TCP而不是http，什么时候使用TCP连接，什么时候使用Http?

Socket 和TCP关系 ？
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
socket则是对TCP/IP协议的封装和应用（程序员层面上）。也可以说，TPC/IP协议是传输层协议，主要解决数据 如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：
“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如
果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也
 可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”

什么时候使用http，什么时候使用tcp
TPC/IP协议是传输层协议，主要解决数据 如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。

HTTP是短连接，Socket(基于TCP协议的)是长连接。尽管HTTP1.1开始支持持久连接，但仍无法保证始终连接。而Socket连接一旦建立TCP三次握手，除非一方主动断开，否则连接状态一直保持。
HTTP的长链接和 TCP的长链接有什么区别？

OpenFeign：Feign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务一样简单， 只需要创建一个接口并添加一个注解即可。
负载均衡发生位置的不同,一般分为服务端负载均衡和客户端负载均衡。
spring cloud的组件及其原理再整理一遍，Nacos注册中心+Ribbon负载均衡+OpenFeign服务调。

------------------------------------------------------------------------------------------------------------------------
TODO
GRPC, 以后能不能所有的重点，都以图的形式表现出来？
RPC原理，RPC都在哪些中间件中应用，Grpc原理，不同的rpc之间有什么区别？
如何掌握一门知识？一个框架？一个知识点？
它是什么，应用场景，为了解决什么问题，架构，组成，它的思想是什么？为什么这样设计？中间件配置需要重点注意的参数，优缺点，同类中横向对比，为什么用它？
读写锁原理
“为了防止并发读写冲突，采用的是写时复制的思想”，写时复制的思想，都有哪些应用场景和案例
设计模式在各中间件的应用，一一找出来。
------------------------------------------------------------------------------------------------------------------------

redis的单线程结构是指其主线程是单线程的。这里主线程包括IO事件的处理，以及IO对应的相关请求的业务处理。此外主线程还负责过期件的处理，复制协调、集群协调等等。这些除了IO事件之外的逻辑会被封装成周期性的任务，由主线程周期性的处理。正因为采用单线程的设计，对于客户端的所有读写请求都由一个主线程串行的处理。因此多个客户端同时对一个键进行写操作的时候，就不会有并发的问题，避免了频繁的上下文切换和锁竞争，使得redis执行起来效率更高。
在QPS峰值的时候，CPU也并没有被跑满。只是由于网络等原因导致并发处理量不能进一步上升，因此CPU并不是制约redis的性能瓶颈。此外大家依旧可以在多核的服务器中启动多个redis实例，来利用多核的特性。
一直在强调的单线程，只是在处理我们的网络请求的时候，只有一个单线程来处理。一个正式的redis server在运行的时候，肯定是不止一个线程的。例如redis进行持久化的时候，会根据实际情况以子进程或者子线程的方式执行。


------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

join()方法是用wait()方法实现，但为什么没有通过notify()系列方法唤醒呀，如果不唤醒，那不就一直等待下去了吗？

原因是：在java中，Thread类线程执行完run()方法后，一定会自动执行notifyAll()方法

/**
     * A thread state.  A thread can be in one of the following states:
     * <ul>
     * <li>{@link #NEW}<br>
     *     A thread that has not yet started is in this state.
     *     </li>
     * <li>{@link #RUNNABLE}<br>
     *     A thread executing in the Java virtual machine is in this state.
     *     </li>



Kafka使用内存映射文件（Memory-Mapped Files）来加速消息的读取和写入操作。这种技术允许Kafka直接将消息存储在操作系统的文件缓存中，而不是通过常规的I/O操作来读取和写入磁盘。

Kafka中使用内存映射文件的主要地方包括：

日志文件：Kafka使用多个日志段（log segment）来存储消息。每个日志段都是一个磁盘上的文件，而这些日志段通过内存映射文件来进行读取和写入。这使得消息的追加和检索操作非常高效。

消费者位移（Consumer Offsets）：Kafka用于跟踪消费者在分区中的位置的位移（offsets）也是使用内存映射文件来存储的。这样可以快速地查找和更新消费者的位移，而不需要进行频繁的磁盘操作。

索引文件：Kafka还使用内存映射文件来存储索引信息，以便快速定位消息的位置。这些索引文件帮助Kafka在消息日志中快速地查找消息，提高了检索的效率。

总的来说，Kafka的使用内存映射文件是为了提高性能，降低读写操作的延迟，特别是对于高吞吐量的消息传输场景非常重要。内存映射文件允许Kafka直接利用操作系统的文件缓存来管理数据，减少了磁盘I/O的开销，从而加速了消息的处理。
