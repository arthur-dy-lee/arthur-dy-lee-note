## mysql锁

### mysql分类锁

mysql锁按模式分，分为乐观锁和悲观锁。

- 乐观锁：数据库的乐观锁一般是业务方通过版本号或时间戳来实现(java一般使用cas，比较的也是版本号)；

- 悲观锁：一般锁全局，使用方式：select... for update（排它锁）

   InnoDB默认Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据)  ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。

**悲观锁的具体流程**

- 在对任意记录进行修改前，先尝试为该记录加上排他锁(exclusive locking);
- 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定;
- 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
- 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

mysql锁按粒度或者范围来分，分为全局锁、表级锁、页面锁和行级锁。下面重点介绍这几种锁

#### 全局锁

```sql
-- 使用全局锁 
flush tables with read lock;
-- 释放全局锁
unlock tables;
```

应用场景: **全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

加上全局锁，意味着整个数据库都是只读状态。在事务支持可重复读的隔离级别下，加参数`–single-transaction`，就会在备份数据库之前先开启事务，不会影响备份数据库时的 Read View。

#### 表级锁(table-level locking)



##### 1. 表锁

表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）

##### a. 共享锁（Shared），又称为S 锁，读锁

针对同一份数据，多个读操作可以同时进行而不会互相影响

##### b. 排它锁（Exclusive），又称为X 锁，写锁。

当前写操作没有完成前，它会阻断其他写锁和读锁

读读-SS之间是可以兼容的，但是读写-SX之间，写写—XX之间是互斥的。

```sql
-- 读锁锁表，会阻塞其他事务修改表数据
LOCK TABLE my_table_name READ;
-- 写锁
lock tables t_stuent write
-- 释放锁
unlock tables
```

**不管是表级锁还是行级锁，都有共享锁和排他锁的概念。有索引，走的是行锁；没有索引，走的是表锁。**

##### 2. 元数据锁(metadata lock)

我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

 目的：MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。

MDL 是在事务提交后才会释放，这意味着**事务执行期间，MDL 是一直持有的**。

那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：

1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
2. 然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，

那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？

这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？

这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。

```sql
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ...
```

# 

##### 3. 意向锁

mysql官网上对于意向锁的解释:

> The main purpose of IX and IS locks is to show that someone is locking a row, or going to lock a row in the table.

意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。

**意向锁可快速判断表里是否有记录被加锁**。之所以需要MDL锁，就是因为事务执行的时候，不能发生表结构的改变，否则就会导致同一个事务中，出现混乱的现象

**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突。表级锁之间才会有冲突，例：和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。**

###### a. 意向共享锁（IS：Intention shared locks）

###### b. 意向排它锁（IX: Intention Exclusive Locks）

也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

select 也是可以对记录加共享锁和独占锁的

```sql
-- 先在表上加上意向共享锁，然后对读取的记录加独占锁
select ... lock in share mode;

-- 先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```



##### 4. AUTO-INC锁

主键自增通过 AUTO-INC 锁实现；AUTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放**。

在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增，一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，**然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。

InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。

- 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
- 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- 当 innodb_autoinc_lock_mode = 1：
  - 普通 insert 语句，自增锁在申请之后就马上释放；
  - 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生**数据不一致的问题**。

要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。**当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题**。

```sql
-- MySQL 8.0.3 之前系统变量innodb_autoinc_lock_mode默认值为1
-- MySQL 8.0.3 之后系统变量innodb_autoinc_lock_mode默认值为2
show variables like 'innodb_autoinc_lock_mode';
```



#### 页面锁(page-level locking)

页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我 们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销 介于表锁和行锁之间，会出现死锁。

每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。



#### 行级锁(row-level locking)

行级锁是mysql中锁定粒度最细的一种锁。表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。

record lock、gap lock、next-key lock，都是加在索引上的。

##### 1. 记录锁（Record Lock）

记录锁，也就是仅仅把一条记录锁上。记录锁是有 S 锁和 X 锁之分的。

##### 2. 间隙锁（Gap Lock）

间隙锁，锁定一个范围，但是不包含记录本身。只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象

间隙锁是前开后开区间，next-Key锁规定是左开右闭区间。

###### 共享锁（S锁：selecdt ... lock in share mode）

###### 排它锁（X锁：select ... for update）

```sql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```



##### 3. 临键锁（Next-Key Lock）

Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。

next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。

##### 4. 插入意向锁

插入意向锁是一种在 INSERT 操作之前设置的一种间隙锁，插入意向锁表示了一种插入意图，即当多个不同的事务，同时往同一个索引的同一个间隙中插入数据的时候，它们互相之间无需等待，即不会阻塞。

只有在可重复读情况下才会生效。

#### 表级锁&行级锁

InnoDB行锁是通过给索引上的索引项加锁来实现的，而不是给表的行记录加锁实现的，这就意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。

表级锁：

- 对整张表加锁。开销小（因为不用去找表的某一行的记录进行加锁，要修改这张表，直接申请加这张表的锁），加锁快，不会出现死锁；
- 锁粒度大，发生锁冲突的概率高，并发度低。

行级锁：

- 对某行记录加锁。开销大（需要找到表中相应的记录，有搜表搜索引的过程），加锁慢，会出现死锁；
- 锁定粒度最小，发生锁冲突的概率最低，并发度高。

#### InnoDB锁总结

1. 在不通过索引条件查询的时候，InnoDB使用的确实是表锁!
2. 由于 MySQL 的行锁是针对索引加的锁,不是针对记录加的锁,所以虽然是访问不同行 的记录,但是如果是使用相同的索引键,是会出现锁冲突的。
3. 当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。
4. 即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫 效率更高,比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查 SQL 的执行计划(explain查看),以确认是否真正使用了索引。

### mysql死锁

#### 死锁的四个条件【互占不循】

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3）不可强行占有: 进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待: 若干进程之间形成一种头尾相接的循环等待资源关系。

#### 命令查看锁信息



```sql
SHOW ENGINE INNODB STATUS;
-- 或者
select * from information_schema.innodb_trx; -- trx_state列字段如果显示LOCK_WAIT则有锁
-- 或者
select * from performance_schema.data_locks\G;
```







#### 哪些场景容易产生死锁

在长事务执行时，执行DDL语句，这时DDL会申请元数据锁，后面的select语句就会堵塞住。